// NOTE: In order for the example to work you need to
//  override the following configuration:
//  contractingWorks:clientId   - The identifier of the Contracting Works client you to interact with
//  contractingWorks:subjectId  - The identifier of the user used to interact with Contracting Works 
//  contractingWorks:apiKey     - The api key used to authentaticate the user above

// Loads the necessary configuration settings from various sources.
// It's recommended to inject these settings using user secrets in Visual Studio.
// The configuration includes client ID, subject ID, API key, and endpoints.
var configuration = new ConfigurationBuilder()
    .AddJsonFile("appsettings.json", true, true)
    .AddUserSecrets<MainApp>(optional: true)
    .AddEnvironmentVariables()
    .Build();

// Extract configuration values for different components.
// These values will be used to set up API connections.
var clientId = configuration.GetValue<string>("contractingWorks:clientId");
var subjectId = configuration.GetValue<string>("contractingWorks:subjectId");
var apiKey = configuration.GetValue<string>("contractingWorks:apiKey");
var authenticationHost = configuration.GetValue<string>("contractingWorks:authenticationHost");
var graphQlHost = configuration.GetValue<string>("contractingWorks:graphQlHost");
var restHost = configuration.GetValue<string>("contractingWorks:restHost");

// Construct base URLs for different endpoints.
// These URLs will be used as a foundation for constructing API requests.
var authenticationBaseUrl = $"https://{authenticationHost}/";
var graphQlBaseUrl = $"https://{graphQlHost}/client/{clientId}/graphql";
var restBaseUrl = $"https://{restHost}";

// Set up the HttpClient for making API requests.
// Configuration includes automatic decompression and a timeout.
var httpMessageHandler = new SocketsHttpHandler()
{
    AutomaticDecompression = DecompressionMethods.All,
};
using var httpClient = new HttpClient(httpMessageHandler)
{
    Timeout = TimeSpan.FromSeconds(170),
};

// Initialize the authentication client to obtain an access token.
var authClient = new DevincoConnectClient(authenticationBaseUrl, httpClient);

// Call the authentication API to get an access token for interacting with other APIs.
var authenticationResponse = await authClient.TokenGenerateAccessTokenAsJsonAsync(
    new()
    {
        ApiKey = apiKey,
        ClientId = 1,
        SubjectId = subjectId,
        TenantId = clientId,
    });
// cwToken is now the token used to interact with the graphQL and restAPI
//  Note the token is valid for 1 hour
var cwToken = authenticationResponse.AccessToken;

// Set up dependency injection using the Host class.
var builder = Host.CreateApplicationBuilder(args);

// Add the HttpClient as a singleton service for efficient HTTP requests.
builder.Services.AddSingleton(httpClient);

// Set up the CW GQL Client (generated by Strawberry Shake) using dependency injection.
builder.Services
    .AddCWGQLClient()
    .ConfigureHttpClient(client => 
    {
        client.BaseAddress = new(graphQlBaseUrl);
        client.DefaultRequestHeaders.Authorization = new("Bearer", cwToken);
    });

// Add the MainApp class as a singleton service.
builder.Services.AddSingleton<MainApp>();

// Build the host using the configured services.
using var host = builder.Build();

var mainApp = host.Services.GetRequiredService<MainApp>();
// Run main app
await mainApp.Run(cwToken, clientId??"<Unknown>", restBaseUrl);

// The MainApp class encapsulates the core functionality of the example.
class MainApp
{
    readonly ILogger<MainApp> _logger;
    readonly CWGQLClient _graphQl;
    readonly HttpClient _httpClient;

    // Constructor injects necessary services for GraphQL and HTTP interactions.
    public MainApp(
        ILogger<MainApp> logger,
        CWGQLClient graphQl,
        HttpClient httpClient)
    {
        _logger = logger;
        _graphQl = graphQl;
        _httpClient = httpClient;
    }

    // The Run method performs the main functionality of the application.
    // It retrieves payment terms and customers using GraphQL,
    // updates payment terms for customers using REST API.
    public async Task Run(string cwToken, string clientId, string restBaseUrl)
    {
        // Give us the first 10 payment terms that are not deactivated (soft deleted)
        var paymentTermResponse = await _graphQl.GetPaymentTerm.ExecuteAsync(
            top:10, 
            filter:"sys_Deactivated = false");

        // Throws if there are any errors.
        paymentTermResponse.EnsureNoErrors();

        // Find the first payment term. Note that values might be null
        //  so using ?. to avoid null reference exceptions is recommended
        var paymentTerm = paymentTermResponse.Data?.PaymentTerms?.Items?.FirstOrDefault();
        if (paymentTerm is null)
        {
            _logger.LogWarning($"No payment terms found :(");
            return;
        }

        var paymentTermDescription = paymentTerm?.Description??"No description";
        _logger.LogInformation($"Found payment term: {paymentTermDescription}");

        // Give us the first 10 customers that are not deactivated (soft deleted)
        var customerResponse = await _graphQl.GetCustomer.ExecuteAsync(
            top:10, 
            filter:"sys_Deactivated = false");

        // Throws if there are any errors.
        customerResponse.EnsureNoErrors();

        // Find the customers payload. Note that values might be null
        //  so using ?. to avoid null reference exceptions is recommended
        var customers = customerResponse?.Data?.Customers?.Items;
        if (customers is null)
        {
            _logger.LogWarning($"No customers found :(");
            return;
        }

        // Print customer information using a loop.
        foreach (var customer in customers)
        {
            _logger.LogInformation($"Customer - {customer.CustomerNumber} - {customer.Name} - {customer.PaymentTerm?.Description??"No payment term"}");
        }

        _logger.LogInformation($"Do you want me to change the payment term of all the customers above to {paymentTermDescription}\nType YES if you do");

        // Prompt user for confirmation before making changes.
        var response = Console.ReadLine()??"";
        if (response != "YES")
        {
            _logger.LogInformation($"Ok I won't do anything then, bye!");
            return;
        }

        _logger.LogInformation($"Ok, updating payment terms of all customers");


        // Prepare an upsert request for changing payment terms of customers.
        var changedCustomers = new List<CustomerDto>();
        foreach (var customer in customers)
        {
            changedCustomers.Add(new ()
            {
                // CustomerId is the primary key of the Customer table
                // By setting this to a non-null value, it indicates that we want to
                // update an existing customer. If it is null, it signifies creating a new customer.
                CustomerId = customer.CustomerId,
                // Set the payment term foreign key of the customer to
                // the payment term id
                PaymentTermId = paymentTerm!.PaymentTermId
            });
        }

            // Initialize a REST client and perform the upsert operation.
            var restClient = new ContractingWorksClient(restBaseUrl, _httpClient)
            {
                CwToken = cwToken,
                Logger  = _logger
            };
        var repsonse = await restClient.V3ClientCustomerUpsertAsync(clientId, null, 0, changedCustomers);

        _logger.LogInformation($"So, the customers are now updated");
    }
}